import { ClassElementMetadataKind } from '../../metadata/models/ClassElementMetadataKind';
import { getBaseType } from '../../prototype/calculations/getBaseType';
import { LegacyTargetImpl } from '../models/LegacyTargetImpl';
export function getTargetsFromMetadataProviders(getClassMetadata, getClassMetadataProperties) {
    return function getTagets(type) {
        const classMetadata = getClassMetadata(type);
        let baseType = getBaseType(type);
        while (baseType !== undefined && baseType !== Object) {
            const classMetadataProperties = getClassMetadataProperties(baseType);
            for (const [propertyKey, propertyValue] of classMetadataProperties) {
                if (!classMetadata.properties.has(propertyKey)) {
                    classMetadata.properties.set(propertyKey, propertyValue);
                }
            }
            baseType = getBaseType(baseType);
        }
        const targets = [];
        for (const constructorArgument of classMetadata.constructorArguments) {
            if (constructorArgument.kind !== ClassElementMetadataKind.unmanaged) {
                const targetName = constructorArgument.targetName ?? '';
                targets.push(new LegacyTargetImpl(targetName, constructorArgument, 'ConstructorArgument'));
            }
        }
        for (const [property, metadata] of classMetadata.properties) {
            if (metadata.kind !== ClassElementMetadataKind.unmanaged) {
                const targetName = metadata.targetName ?? property;
                targets.push(new LegacyTargetImpl(targetName, metadata, 'ClassProperty'));
            }
        }
        return targets;
    };
}
//# sourceMappingURL=getTargetsFromMetadataProviders.js.map