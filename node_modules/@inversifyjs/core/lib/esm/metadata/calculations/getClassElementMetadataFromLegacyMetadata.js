import { InversifyCoreError } from '../../error/models/InversifyCoreError';
import { InversifyCoreErrorKind } from '../../error/models/InversifyCoreErrorKind';
import { INJECT_TAG, MULTI_INJECT_TAG, NAME_TAG, NAMED_TAG, NON_CUSTOM_TAG_KEYS, OPTIONAL_TAG, UNMANAGED_TAG, } from '../../reflectMetadata/data/keys';
import { ClassElementMetadataKind } from '../models/ClassElementMetadataKind';
export function getClassElementMetadataFromLegacyMetadata(metadataList) {
    const injectMetadata = metadataList.find((metadata) => metadata.key === INJECT_TAG);
    const multiInjectMetadata = metadataList.find((metadata) => metadata.key === MULTI_INJECT_TAG);
    const unmanagedMetadata = metadataList.find((metadata) => metadata.key === UNMANAGED_TAG);
    if (unmanagedMetadata !== undefined) {
        return getUnmanagedClassElementMetadata(injectMetadata, multiInjectMetadata);
    }
    if (multiInjectMetadata === undefined && injectMetadata === undefined) {
        throw new InversifyCoreError(InversifyCoreErrorKind.missingInjectionDecorator, 'Expected @inject, @multiInject or @unmanaged metadata');
    }
    const nameMetadata = metadataList.find((metadata) => metadata.key === NAMED_TAG);
    const optionalMetadata = metadataList.find((metadata) => metadata.key === OPTIONAL_TAG);
    const targetNameMetadata = metadataList.find((metadata) => metadata.key === NAME_TAG);
    const managedClassElementMetadata = {
        kind: injectMetadata === undefined
            ? ClassElementMetadataKind.multipleInjection
            : ClassElementMetadataKind.singleInjection,
        name: nameMetadata?.value,
        optional: optionalMetadata !== undefined,
        tags: new Map(metadataList
            .filter((metadata) => NON_CUSTOM_TAG_KEYS.every((customTagKey) => metadata.key !== customTagKey))
            .map((metadata) => [
            metadata.key,
            metadata.value,
        ])),
        targetName: targetNameMetadata?.value,
        value: injectMetadata === undefined
            ? multiInjectMetadata?.value
            : injectMetadata.value,
    };
    return managedClassElementMetadata;
}
function getUnmanagedClassElementMetadata(injectMetadata, multiInjectMetadata) {
    if (multiInjectMetadata !== undefined || injectMetadata !== undefined) {
        throw new InversifyCoreError(InversifyCoreErrorKind.missingInjectionDecorator, 'Expected a single @inject, @multiInject or @unmanaged metadata');
    }
    return {
        kind: ClassElementMetadataKind.unmanaged,
    };
}
//# sourceMappingURL=getClassElementMetadataFromLegacyMetadata.js.map